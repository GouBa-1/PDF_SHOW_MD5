import subprocess
import struct
import psutil
import time
import sys
import os


#前缀数据
Prefix=["./hex/f0.bin","./hex/f1.bin","./hex/f2.bin","./hex/f3.bin","./hex/f4.bin","./hex/f5.bin","./hex/f6.bin","./hex/f7.bin","./hex/f8.bin","./hex/f9.bin","./hex/f10.bin","./hex/f11.bin","./hex/f12.bin","./hex/f13.bin","./hex/f14.bin","./hex/f15.bin","./hex/f16.bin","./hex/f17.bin","./hex/f18.bin","./hex/f19.bin","./hex/f20.bin","./hex/f21.bin","./hex/f22.bin","./hex/f23.bin","./hex/f24.bin","./hex/f25.bin","./hex/f26.bin","./hex/f27.bin","./hex/f28.bin","./hex/f29.bin","./hex/f30.bin","./hex/f31.bin","./hex/f32.bin","./hex/f33.bin","./hex/f34.bin","./hex/f35.bin"]
#图片数据
Picture=["./hex/p0.bin","./hex/p1.bin","./hex/p2.bin","./hex/p3.bin","./hex/p4.bin","./hex/p5.bin","./hex/p6.bin","./hex/p7.bin","./hex/p8.bin","./hex/p9.bin","./hex/pa.bin","./hex/pb.bin","./hex/pc.bin","./hex/pd.bin","./hex/pe.bin","./hex/pf.bin"]
b_name=""

def get_last(data):
    addr=len(data)-1
    #print(addr)
    while(addr>0):
        #print(hex(data[addr]))
        if data[addr]==0xfe:
            tmp_addr=addr-1
            if data[tmp_addr]==0xff:
                return tmp_addr
        addr-=1

def unicoll_one(cnt):
    #prefix_stream 以二进制形式打开prefix
    #predix_data 读取prefix_stream的所有数据
    #prefix_len 获得prefix_data数据长度
    #F是用来检测上次是否超时,默认为0,超时为1
    F=0
    if sys.argv[2]:
        C=int(sys.argv[2])
    else:
        C=0
        
    while C<=15:
        Cnt=str(C)
        b_name=str(cnt)+"_x.bin"
        bb_name=str(cnt)+"_x_c.bin"
        bbb_name=str(cnt)+'_x_last.bin'
        
        #如果上次超时,则删去上次生成的文件
        if F==1:
            F=0
            open(b_name,"wb").write(open(bbb_name,'rb').read())
            os.system("rm -rf "+str(cnt)+'_'+str(C+1)+".bin")
            for i in range(C):
                open(str(cnt)+"_"+str(i)+".bin","wb").write(open(str(cnt)+"_"+str(i)+"_c.bin","rb").read())
            last_data=open(bb_name,'rb').read()
            open(b_name,'wb').write(last_data)

        if Cnt=='0':
            os.system("cat "+b_name)
            print(b_name)
            os.system("cat "+bb_name)
            print(bb_name)
            prefix=Prefix[cnt]
            if cnt==0:
                b=open(prefix,"rb").read()
            if cnt!=0:
                bb=str(cnt-1)+"_x.bin"
                b=open(bb,"rb").read()
                b+=open(prefix,"rb").read()
            open(b_name,"wb").write(b)
            open(bb_name,"wb").write(b)

        for i in range (1):
            if C>0:
                open(bbb_name,"wb").write(open(bb_name,'rb').read())
            prefix=b_name
            picture=Picture[int(Cnt)]
            prefix_stream=open(prefix,"rb")
            prefix_data=prefix_stream.read()
            open(bb_name,"wb").write(prefix_data)
            prefix_len=len(prefix_data)
            prefix_stream.close()
                
            #获得最后一个0xFFFE的地址
            last_addr=get_last(prefix_data)
            #print("last fffe is in "+str(last_addr))
    
            #获得长度的地址,以及长度
            len1_addr=last_addr+2
            len2_addr=last_addr+3
            c_len=prefix_data[len1_addr]*0x100+prefix_data[len2_addr]

            #计算下一次0xFFFE应该出现的位置,除非将出现在x*0x80+7地址的位置,否则都是不符合下一次构造的
            #处理:直接开始用\x00填充到下一次0xFFFE,并且计算当前len1_addr到下一次符合的位置的距离
            #print(hex(len1_addr))
            #print(hex(c_len))
            next_chunk=len1_addr+c_len#下一个chunk的位置
            if (next_chunk-7)%0x80!=0:
                prefix_data+=(b'\x00'*(-(len(prefix_data)-len1_addr)+c_len))
                prefix_data+=(b'\xff\xfe')#直接跑到下一个chunk,开始布置
                #下一次构造注释块的长度
                #通过next_chunk来算当前chunk在0x80中的位置
                #next_chunk%80
                #print(hex(next_chunk))
                #print(hex(next_chunk%0x80))
                tmp=0x80-(next_chunk%0x80)-2
                #print(hex(tmp))
                pad_len=bytes([tmp])
                #print(pad_len)
                prefix_data+=(b'\x00'+pad_len)
                prefix_data+=b'\x00'*(tmp-2)

            #如果数据长度不能整除0x80, 则进行补全
            prefix_len=len(prefix_data)
            if prefix_len%0x80!=0:
                tmp_len=prefix_len%0x80
                #print(hex(int(tmp_len)))
                tmp_len=0x80-tmp_len
                tmp_len=int(tmp_len)
                #print(hex(tmp_len))
                for cnt in range(tmp_len):
                    prefix_data+=b'\x00'

            #补入前缀
            pre=b"\x00"*7+b'\xff'+b'\xfe'+b'\x00'+b'\x80'+b'\x00'*6
            prefix_data+=pre
            prefix_stream=open(b_name,"wb")
            for c in prefix_data:
                s=struct.pack("B",c)
                prefix_stream.write(s)
            prefix_stream.close()
        
            shell_1="../scripts/poc_no.sh "+b_name
            #print(shell_1)
            #os.system(shell_1)

            parent=subprocess.Popen(shell_1,shell=True)
            for _ in range(300): # 250 seconds
                if parent.poll() is not None:  # process just ended
                    break
                time.sleep(1)
            else:
                # the for loop ended without break: timeout
                parent = psutil.Process(parent.pid)
                for child in parent.children(recursive=True):  # or parent.children() for recursive=False
                    child.kill()
                    parent.kill()
                #如果超时F置1,退出当前循环
                print("TIME OUT")
                F=1
                if C>0:
                    C-=2
                else:
                    C-=1
                break


            print("WxWWxxWWWxxxWWWWxxxxWWWWWW*+=Finish=+*WWWWWxxxxWWWWxxxWWWxxWWxW")
                
            #一次碰撞完毕
            #collision1为小,collision2为大
        
            collision1=open("./collision1.bin","rb")
            collision2=open("./collision2.bin","rb")
            name1=b_name
            name2=str(cnt)+"_"+Cnt+".bin"
            os.system("cat "+name2)
            c1_data=collision1.read()
            c2_data=collision2.read()
            collision1.close()
            collision2.close()
            uncertain=open(name1,"wb")
            certain=open(name2,"wb")
            #print(name1)
            #print(name2)
            c_addr=len(c1_data)
            c_addr=c_addr-0x77
            #插入先插入0x80用的FFFE
            payload=b'\x00'*9
            payload+=b'\xff\xfe\x02\x00'
            payload+=b'\x00'*12
            payload+=b'\x00'*16*0xf
            pict=open(picture,'rb')
            pict_data=pict.read()
            payload+=pict_data
            payload+=b'\xff\xfe'
            #获得距离结尾的长度
            pp_tmp=c1_data+payload
            pp_len=len(pp_tmp)%0x3300#长度所处地址
            pp_len=0x3300-pp_len
            p1=pp_len/0x100
            p2=pp_len%0x100
            print("p1: "+hex(int(p1)))
            print("p2: "+hex(int(p2)))
            p1=bytes([int(p1)])
            p2=bytes([int(p2)])
            payload+=(p1+p2)
            begin=0xb
            payload_len=len(payload)
            p_len=payload_len-begin
            p_len=0x200-p_len
            payload+=p_len*b'\x00'
            payload+=b'\xff\xfe\x00\x10'
            c1_data+=payload
            c2_data+=payload
            uncertain.write(c1_data)
            certain.write(c2_data)
            uncertain.close()
            certain.close()
            #完整一次结束,则将新的碰撞块替换旧的
            if C>0:
                data=get_padding(c1_data)
                for old in range (C):
                    old_name=str(cnt)+"_"+str(old)+".bin"
                    old_name_c=str(cnt)+"_"+str(old)+"_c.bin"
                    print(old_name+" will change!")
                    old_data=open(old_name,"rb").read()
                    print(str(old))
                    print(str(C-1))
                    if old==(C-1):
                        command1="cat "+old_name_c
                        os.system(command1)
                    open(old_name_c,"wb").write(old_data)
                    old_data+=data
                    open(old_name,"wb").write(old_data)
            C=C+1
            break

                        
def get_padding(data):
    cnt=len(data)-1
    tmp=cnt
    print("aa==========================================================================================================================================================aa")
    #for c in data:
    #    print(data)
    while 1:
        #if data[cnt-1]==0x10 and data[cnt-2]==0x00 and data[cnt-3]==0xfe and data[cnt-4]==0xff:
        if data[cnt-1]==0x10 and data[cnt-2]==0x00 and data[cnt-3]==0xfe and data[cnt-4]==0xff:
            print(hex(cnt))
            break
        cnt=cnt-1
    cnt=cnt
    data=data[cnt:]
    #print(padding)
    return data

if sys.argv[1]:
    cnt=int(sys.argv[1])
else:
    cnt=0


unicoll_one(cnt)
x_name=str(cnt)+'_x.bin'
x_data=open(x_name,'rb').read()
x_len=len(x_data)
x_len%=0x3300
x_padding_len=0x3300-x_len-3
pre=int(x_padding_len/0x100)
tai=int(x_padding_len%0x100)
padding=(bytes([pre])+bytes([tai]))
padding+=b'\x00'*(x_padding_len-1)
padding+=b'\xff\xd9\x0a\x65\x6e\x64\x73\x74\x72\x65\x61\x6d\x0a\x65\x6e\x64\x6f\x62\x6a\x0a'
for i in range(16):
    old_name=str(cnt)+'_'+str(i)+'.bin'
    print(old_name)
    old_data=open(old_name,"rb").read()
    old_data=old_data[:-2]
    old_data+=padding
    open(old_name,"wb").write(old_data)
old_name=str(cnt)+'_x.bin'
print(old_name)
old_data=open(old_name,"rb").read()
old_data=old_data[:-2]
old_data+=padding
open(old_name,"wb").write(old_data)